#!/usr/bin/env bash

# Use Gitâ€™s colored diff when available
hash git &>/dev/null;
if [ $? -eq 0 ]; then
  function diff() {
    git diff --no-index --color-words "$@";
  }
fi;

# Git: Prepend current branch name to commit message
function gcb() {
  CURRENT_BRANCH=$(git_branch_name)

  if [ $CURRENT_BRANCH == "master" ] ; then
    echo "Currently on master"
    return
  fi

  COMMIT_BRANCH=$(echo "$CURRENT_BRANCH" | sed -E 's/^(feature|hotfix|release)\///')

  git commit -m "$COMMIT_BRANCH: $1"
}

# Git: Determine current git branch
function git_branch_name() {
  git rev-parse --abbrev-ref HEAD
}

# Git: Count committed lines per author
function git_line_count() {
  if [ -z "$1" ] ; then
    FILES=`git ls-files .`
  else
    FILES=`git ls-files $1`
  fi

  echo $FILES | xargs -n1 git blame -wM --line-porcelain | sed -n 's/^author //p' | sort -f | uniq -ic | sort -nr
}

# Git: Clean current branch after it's been merged
function gmerged() {
  readonly BRANCH=$(git_branch_name)

  if [ $BRANCH == "master" ] ; then
    echo "Cannot prune master"
    return
  fi

  readonly TRUNK="master"
  FORCE=false

  for i in "$@" ; do
    case "$i" in
      ( -f | --force ) FORCE=true; shift;;
      ( * ) TRUNK=$1; shift;;
    esac
  done

  if [ $FORCE == true ] ; then
    DELETE_FLAG="D"
  else
    DELETE_FLAG="d"
  fi

  if [ $BRANCH == $TRUNK ] ; then
    echo "Cannot prune into self"
    return
  fi

  git stash && git checkout $TRUNK && git pull origin $TRUNK && git branch -${DELETE_FLAG} $BRANCH && git branch -${DELETE_FLAG}r origin/$BRANCH
}

# Git: Enter interactive mode to squash the number of commits specified
function gsquash() {
  if [ -z "$1" ] ; then
    echo "Usage: squash <num_commits>"
    return
  fi

  git stash && git rebase -i HEAD~$1
}

# Install linux ISO to the selected device
function install-linux() {
  if [[ $# -eq 0 ]] ; then
    echo 'Input file required'
    exit 1
  fi

  if [ ! -f $1 ]; then
      echo "Input file not found."
      exit 1
  fi

  lsblk -o NAME,LABEL

  echo ""
  read -p "Which device would you like install to? " input

  DEVICE=/dev/$input

  if [ ! -b $DEVICE ] ; then
      echo "Invalid device"
      exit 1
  fi

  SIZE=`stat --print="%s" $1`

  date
  sudo bash -c "dd if=$1 | pv -s $SIZE | dd of=$DEVICE bs=4M"
  date
}

# Reset all directory and file permissions to 0775 and 0664, respectively, in the current directory
function reset-chmod() {
  find . -type d -print0 | xargs -0 chmod 0775
  find . -type f -print0 | xargs -0 chmod 0664
}

# Touch all files under the current directory
function touch-files() {
  find . -type f -print0 | xargs -0 touch
}

# Wipe selected device by overwriting with random data
function wipe-device() {
  lsblk -o NAME,LABEL

  echo ""
  read -p "Which device would you like to wipe? " input

  DEVICE=/dev/$input

  if [ ! -b $DEVICE ] ; then
      echo "Invalid device"
      return
  fi

  SIZE=`sudo blockdev --getsize64 $DEVICE`

  date
  sudo bash -c "dd if=/dev/urandom | pv -s $SIZE | dd of=$DEVICE bs=4M"
  date
}
